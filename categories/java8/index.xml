<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java8 on 豆子.学习笔记</title>
    <link>https://binbean.github.io/categories/java8/</link>
    <description>Recent content in Java8 on 豆子.学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 06 Sep 2018 14:36:27 +0800</lastBuildDate>
    
	<atom:link href="https://binbean.github.io/categories/java8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java8学习五 Stream之使用流收集数据</title>
      <link>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%BA%94-stream%E4%B9%8B%E4%BD%BF%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 06 Sep 2018 14:36:27 +0800</pubDate>
      
      <guid>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%BA%94-stream%E4%B9%8B%E4%BD%BF%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE/</guid>
      <description>具体地说，流收集器是对流调用collect方法将对流中的元素触发一个归约操作（ 由Collector来参数化）。
归约和汇总 计数counting // 计算菜单中菜的总数 menu.stream().collect(Collectors.counting()) menu.stream().count()  最大值和最小值  最大值maxBy  menu.stream().collect(Collectors.maxBy(Comparator .comparingInt(Dish::getCalories)));  //使用reduceing实现相同功能 menu.stream().collect(Collectors .reducing((Dish d1, Dish d2) -&amp;gt; d1.getCalories() &amp;gt; d2.getCalories() ? d1 : d2));   最小值 minBy  menu.stream().collect(Collectors.minBy( Comparator.comparingInt(Dish::getCalories) ));  汇总  summingInt  menu.stream().collect(Collectors.summingInt(Dish::getCalories)  //使用reduceing实现相同功能 //方式一 menu.stream().collect(Collectors.reducing(0, Dish::getCalories, (a, b) -&amp;gt; a + b)); // 方式二 menu.stream().collect((Collectors.reducing(0, Dish:: getCalories, Integer:: sum)));   summarizingInt得到总和、平均值、最大值、最小值  menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));   输出结果为：</description>
    </item>
    
    <item>
      <title>Java8学习四 Stream之使用流</title>
      <link>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E5%9B%9B-stream%E4%B9%8B%E4%BD%BF%E7%94%A8%E6%B5%81/</link>
      <pubDate>Tue, 04 Sep 2018 21:55:07 +0800</pubDate>
      
      <guid>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E5%9B%9B-stream%E4%B9%8B%E4%BD%BF%E7%94%A8%E6%B5%81/</guid>
      <description>筛选和切片 用谓词筛选-filter menu.stream() .filter(Dish::isVegetarian) .collect(Collectors.toList());  取重-distinct List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream() .filter(integer -&amp;gt; integer % 2 == 0) .distinct() .forEach(System.out:: println);  截短流-limit menu.stream().filter(dish -&amp;gt; dish.getCalories() &amp;gt; 300) .limit(3) .forEach(System.out:: println);  跳过元素-skip menu.stream().filter(dish -&amp;gt; dish.getCalories() &amp;gt; 300) .skip(2) .forEach(System.out:: println);  映射 map 获取菜单中菜名的length。
menu.stream() .map(Dish::getName) .map(String::length) .forEach(System.out:: println);  flatMap 拆分单词字母并取重。
List&amp;lt;String&amp;gt; words = Arrays.asList(&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;); // ❌错误，返回2个字符串数组 words.stream().map(word -&amp;gt; word.</description>
    </item>
    
    <item>
      <title>Java8学习三 Stream之认识流</title>
      <link>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%B8%89-stream%E4%B9%8B%E8%AE%A4%E8%AF%86%E6%B5%81/</link>
      <pubDate>Sun, 02 Sep 2018 10:10:44 +0800</pubDate>
      
      <guid>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%B8%89-stream%E4%B9%8B%E8%AE%A4%E8%AF%86%E6%B5%81/</guid>
      <description>流式是什么 流是Java API新成员，允许以声明的方式处理数据集合。主要特点：
 流水线-多个操作可以链接起来形成一个流水线 内部迭代  比如：获取卡路里小于400的菜名并按卡路里排序（升序）。
Java8之前
// 筛选&amp;lt;400 List&amp;lt; Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for( Dish d: menu){ if( d. getCalories() &amp;lt; 400){ lowCaloricDishes. add( d); } } // 排序 Collections.sort( lowCaloricDishes, new Comparator&amp;lt; Dish&amp;gt;() { public int compare( Dish d1, Dish d2){ return Integer. compare( d1. getCalories(), d2. getCalories()); }); // 获取名称 List&amp;lt; String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;(); for( Dish d: lowCaloricDishes){ lowCaloricDishesName. add( d. getName()); }  Java8之后</description>
    </item>
    
    <item>
      <title>Java8学习二 Lambda表达式</title>
      <link>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%BA%8C-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 30 Aug 2018 23:15:03 +0800</pubDate>
      
      <guid>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%BA%8C-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>什么是Lambda表达式 Lambda表达式可以理解为一种匿名函数：没有名称，但有参数列表、函数体和返回类型，可能还有一个可抛出异常列表
Lambda表达式组成   (parameters) -&amp;gt; expression (parameters) -&amp;gt; {expression;}    $$ \underbrace{(Apple \quad a1, Apple \quad a2)}_{参数列表}\quad \overbrace{-}^{箭头}\quad \underbrace{a1.getWeight()-a2.getWeight()}_{函数主体} $$  在哪里以及如何使用Lambda表达式 在函数式接口上使用Lambda表达式。
函数式接口 只定义了一个抽象方法的接口（Java8中接口有默认方法）
函数描述符 函数式接口的抽象方法签名，即接受什么参数，返回什么值类型。
 例如：() -&amp;gt; void,没有参数也没有返回值，这正是Runable接口的代表。
 @FunctionalInterface 这个标注用于表示该接口会设计成一个函数式接口。 如果你用@FunctionalInterface定义了一个接口， 而它却不是函数式接口的话， 编译器将返回一个提示原因的错误。 例如，错误消息可能是“ Multiple non- overriding abstract methods found in interface Foo”。
使用函数式接口 Java8提供，在java.util.function包中
 Predicate  接口: (T) -&amp;gt; boolean
@FunctionalInterface public interface Predicate&amp;lt; T&amp;gt;{ boolean test( T t); }  使用示例：过滤空字符串</description>
    </item>
    
    <item>
      <title>Java8学习一 通过行为参数化传递代码</title>
      <link>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%B8%80-%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 29 Aug 2018 21:00:13 +0800</pubDate>
      
      <guid>https://binbean.github.io/post/java8%E5%AD%A6%E4%B9%A0%E4%B8%80-%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/</guid>
      <description>什么是行为参数化？ 一个方法接收多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。
有什么好处？ 让代码更好的适应不断变化的要求，对付啰嗦，减轻未来的变化量。
问题 对苹果按要求进行筛选，比如：重量、颜色等（*需求是变化的哦*）
Apple类
public class Apple { private int weight; private String color; public Apple(int weight, String color){ this.weight = weight; this.color = color; } // getter and setter @Override public String toString() { return &amp;quot;Apple{&amp;quot; + &amp;quot;weight=&amp;quot; + weight + &amp;quot;, color=&#39;&amp;quot; + color + &#39;\&#39;&#39; + &#39;}&#39;; } }  Bad code 筛选方法
//按颜色筛选，传递颜色参数 public static List&amp;lt; Apple&amp;gt; filterApplesByColor( List&amp;lt; Apple&amp;gt; inventory, String color) { List&amp;lt; Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (Apple apple: inventory){ if ( apple.</description>
    </item>
    
  </channel>
</rss>