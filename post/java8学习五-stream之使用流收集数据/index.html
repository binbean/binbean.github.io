<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css" rel="stylesheet">
  
  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

	
	MathJax.Hub.Config({
	  tex2jax: {
	    inlineMath: [['$','$'], ['\\(','\\)']],
	    displayMath: [['$$','$$'], ['\[','\]']],
	    processEscapes: true,
	    processEnvironments: true,
	    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	    TeX: { equationNumbers: { autoNumber: "AMS" },
	         extensions: ["AMSmath.js", "AMSsymbols.js"] }
	  }
	});

	MathJax.Hub.Queue(function() {
	    
	    
	    
	    var all = MathJax.Hub.getAllJax(), i;
	    for(i = 0; i < all.length; i += 1) {
	        all[i].SourceElement().parentNode.className += ' has-jax';
	    }
	});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>


  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.41" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <meta content="Java8, Stream, Java8流" name="keywords">
  <meta content="Java8学习五 Stream之使用流收集数据" property="og:title">
  <meta content="Java8 Stream，流的使用，包括：归约汇总、分组、分区等。" property="og:description">
  

  <title>Java8学习五 Stream之使用流收集数据 &middot; Binbean.学习笔记</title>

  
  <link type="text/css" rel="stylesheet" href="https://binbean.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://binbean.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://binbean.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://binbean.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Binbean.学习笔记" />

  
</head>

  <body class=" ">
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://binbean.github.io/"><h1>Binbean.学习笔记</h1></a>
      <br/>
      <br/>
      <p class="lead">
       The Coder of Java 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://binbean.github.io/">首页</a> </li>
      <li><a href="https://binbean.github.io//categories/">分类</a> </li>
      <li><a href="https://binbean.github.io//tags/">标签</a> </li>
      
    </ul>

    <br/>
    <br/>
    <p>Copyright (c) 2018, BinBin Wen</p>
    <p>Powered by Hugo 0.40.3</p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Java8学习五 Stream之使用流收集数据</h1>
  <span class="post-date">2018-09-06 22:36:27
    
  </span>
  

<p>具体地说，流收集器是对流调用collect方法将对流中的元素触发一个归约操作（ 由Collector来参数化）。</p>

<h3 id="归约和汇总">归约和汇总</h3>

<h4 id="计数-counting">计数<code>counting</code></h4>

<pre><code class="language-java">// 计算菜单中菜的总数
menu.stream().collect(Collectors.counting())
menu.stream().count()
</code></pre>

<h4 id="最大值和最小值">最大值和最小值</h4>

<ul>
<li>最大值<code>maxBy</code></li>
</ul>

<pre><code class="language-java">menu.stream().collect(Collectors.maxBy(Comparator
  .comparingInt(Dish::getCalories)));
</code></pre>

<pre><code class="language-java">//使用reduceing实现相同功能
menu.stream().collect(Collectors
  .reducing((Dish d1, Dish d2) -&gt; d1.getCalories() &gt; 
    d2.getCalories() ? d1 : d2));
</code></pre>

<ul>
<li>最小值 <code>minBy</code></li>
</ul>

<pre><code class="language-java"> menu.stream().collect(Collectors.minBy(
     Comparator.comparingInt(Dish::getCalories)
 ));
</code></pre>

<h4 id="汇总">汇总</h4>

<ul>
<li><code>summingInt</code></li>
</ul>

<pre><code class="language-java">menu.stream().collect(Collectors.summingInt(Dish::getCalories)
</code></pre>

<pre><code class="language-java">//使用reduceing实现相同功能
//方式一
menu.stream().collect(Collectors.reducing(0, Dish::getCalories, 
     (a, b) -&gt; a + b));
// 方式二 
menu.stream().collect((Collectors.reducing(0, 
     Dish:: getCalories, Integer:: sum)));
</code></pre>

<ul>
<li><code>summarizingInt</code>得到总和、平均值、最大值、最小值</li>
</ul>

<pre><code class="language-java">menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));
</code></pre>

<blockquote>
<p>输出结果为：</p>

<p><code>IntSummaryStatistics{count=9, sum=4200, min=120, average=466.666667, max=800}</code></p>

<p>相应的<code>summarizingLong</code>和<code>summarizingDouble</code>工厂方法对应相关的<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>类型。</p>
</blockquote>

<h4 id="连接字符串">连接字符串</h4>

<pre><code class="language-java">//默认空格连接
menu.stream().map(Dish::getName).collect(Collectors.joining());
// ,连接
menu.stream().map(Dish::getName).collect(Collectors.joining(&quot;,&quot;))
 // reduce方式连接, 返回Optinal
menu.stream().map(Dish::getName).reduce(String::concat);
</code></pre>

<blockquote>
<p>joining 内部使用StringBuilder连接字符串。</p>
</blockquote>

<h4 id="collectors-reducing"><code>Collectors.reducing</code></h4>

<p><code>Collectors.reducing</code>工厂方法是所有归约汇总方法的一般化，即上述所有功能都可通过<code>reducing</code>实现。</p>

<blockquote>
<p><code>reducing</code>方法接收三个参数</p>

<ul>
<li>第一个参数，归约操作的起始值</li>
<li>第二个参数，<code>Function&lt;T, R&gt;</code>类型</li>
<li>第三个参数，<code>BinaryOperator&lt;U&gt;</code>类型</li>
</ul>
</blockquote>

<h3 id="分组">分组</h3>

<h4 id="简单分组">简单分组</h4>

<pre><code class="language-java">//根据菜的类型分组
Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishByType = menu.stream()
    .collect(Collectors.groupingBy(Dish::getType));
</code></pre>

<pre><code class="language-java">public enum CaloricLevel{
    DIET,NORMAL,FAT
}

//根据卡路里情况分组
Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishByCaloric = menu.stream()
    .collect(Collectors.groupingBy(dish -&gt; {
        if (dish.getCalories() &lt;= 400 ){
            return CaloricLevel.DIET;
        }else if (dish.getCalories() &lt;= 700) {
            return  CaloricLevel.NORMAL;
        }else {
            return CaloricLevel.FAT;
        }
    }));
</code></pre>

<h4 id="多级分组">多级分组</h4>

<ul>
<li>根据类型和卡路里分组</li>
</ul>

<pre><code class="language-java">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishByTypeCaloricLevel = menu.stream().collect(
           Collectors.groupingBy(Dish::getType,
                   Collectors.groupingBy(dish -&gt; {
                       if (dish.getCalories() &lt;= 400 ){
                           return CaloricLevel.DIET;
                       }else if (dish.getCalories() &lt;= 700) {
                           return  CaloricLevel.NORMAL;
                       }else {
                           return CaloricLevel.FAT;
                       }
                   })
           )
        );
</code></pre>

<ul>
<li>按类型分组并计算每组数量</li>
</ul>

<pre><code class="language-java">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().
    collect(Collectors.groupingBy(Dish::getType, Collectors.counting()));
</code></pre>

<ul>
<li>按类型分组并查找卡路里最大的</li>
</ul>

<pre><code class="language-java">//返回Optional类型
 Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; typesMostCaloriesOP = menu.stream()
     .collect( Collectors.groupingBy(Dish::getType,
            Collectors.maxBy(
                Comparator.comparingInt(Dish:: getCalories)
            )
     )
);
</code></pre>

<blockquote>
<p>把收集器结果转换为另一种类型：<code>Collectors.collectingAndThen</code></p>
</blockquote>

<pre><code class="language-java">//返回Dish类型
Map&lt;Dish.Type, Dish&gt; typesMostCalories = menu.stream()
    .collect(Collectors.groupingBy(Dish::getType,
         Collectors.collectingAndThen(
              Collectors.maxBy(
                  Comparator.comparingInt(Dish:: getCalories)),
             Optional::get))
        );
</code></pre>

<ul>
<li>按类型分组并计算热量总和</li>
</ul>

<pre><code class="language-java">Map&lt;Dish.Type, Integer&gt; typesCaloriesCount = menu.stream().
    collect(Collectors.groupingBy(Dish::getType,
                Collectors.summingInt(Dish::getCalories)));
</code></pre>

<ul>
<li>按类型分组并映射为卡路里级别<code>Collectors.mapping</code></li>
</ul>

<pre><code class="language-java">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelByType = menu.stream().
    collect(Collectors.groupingBy(Dish::getType, 
              Collectors.mapping((Dish dish) -&gt; {
                    if (dish.getCalories() &lt;= 400 ){
                        return CaloricLevel.DIET;
                    }else if (dish.getCalories() &lt;= 700) {
                        return  CaloricLevel.NORMAL;
                    }else {
                        return CaloricLevel.FAT;
                    }
                }, Collectors.toCollection(HashSet::new)/*Collectors.toSet()*/)));
</code></pre>

<h3 id="分区">分区</h3>

<p>由一个谓词（返回一个布尔值的函数）作为分类函数，称为分区函数。意味着分组Map的键类型为Boolean，最多可分两组——true一组，false一组。</p>

<ul>
<li>按照是否是素菜分区</li>
</ul>

<pre><code class="language-java">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = menu.stream().
    collect(Collectors.partitioningBy(Dish:: isVegetarian));
</code></pre>

<ul>
<li>按照是否是素菜分区并按类型分组</li>
</ul>

<pre><code class="language-java">Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; partitionedMenuGroupByType = menu.stream().collect(
     Collectors.partitioningBy(Dish::isVegetarian,
     Collectors.groupingBy(Dish::getType))
</code></pre>

<ul>
<li>数字按质数和非质数分区</li>
</ul>

<pre><code class="language-java">public static boolean isPrime(int candidate){
    int candidateRoot = (int) Math.sqrt((double) candidate);
    return IntStream.rangeClosed(2, candidateRoot)
        .noneMatch(i -&gt; candidate % i == 0);
}

public static Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(int n){
    return IntStream.rangeClosed(2, n)
        .boxed()
        .collect(Collectors.partitioningBy(candidate -&gt; isPrime(candidate)));
}
partitionPrimes(20)
</code></pre>

<hr />

<blockquote>
<p>本文为学习记录，因能力有限，如有错误请赐教……如需转载，请注明出处！</p>
</blockquote>

</div>
<hr />
<blockquote>
<p>本文为学习过程记录，因能力有限，如有错误请赐教……如需转载，请注明出处！<a href="https://binbean.github.io/">https://binbean.github.io</a></p>
</blockquote>




<div id="git-comments"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
  var gitment = new Gitment({
    id: '20180906223627',  
    owner: 'binbean',
    repo: 'Gitment',
    oauth: {
      client_id: '5abe7f2c0a045b632a03',
      client_secret: '5e344f27030ca6bff90af981e47272a1848e3bea',
    }
  })
  gitment.render('git-comments')
</script>
    </div>

    
  </body>
</html>
