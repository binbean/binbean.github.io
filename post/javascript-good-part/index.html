<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/monokai.min.css" rel="stylesheet">
  
  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">

	
	MathJax.Hub.Config({
	  tex2jax: {
	    inlineMath: [['$','$'], ['\\(','\\)']],
	    displayMath: [['$$','$$'], ['\[','\]']],
	    processEscapes: true,
	    processEnvironments: true,
	    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	    TeX: { equationNumbers: { autoNumber: "AMS" },
	         extensions: ["AMSmath.js", "AMSsymbols.js"] }
	  }
	});

	MathJax.Hub.Queue(function() {
	    
	    
	    
	    var all = MathJax.Hub.getAllJax(), i;
	    for(i = 0; i < all.length; i += 1) {
	        all[i].SourceElement().parentNode.className += ' has-jax';
	    }
	});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>


  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.41" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <meta content="Javascript, 原型链" name="keywords">
  <meta content="Javascript Good Part读书笔记" property="og:title">
  <meta content="Javascript Good Part读书笔记，包括JavaScript语法、原型链、对象、函数、继承等。" property="og:description">
  

  <title>Javascript Good Part读书笔记 &middot; Binbean.学习笔记</title>

  
  <link type="text/css" rel="stylesheet" href="http://binbean.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://binbean.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://binbean.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://binbean.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Binbean.学习笔记" />

  
</head>

  <body class=" ">
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://binbean.github.io/"><h1>Binbean.学习笔记</h1></a>
      <br/>
      <br/>
      <p class="lead">
       The Coder of Java 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="http://binbean.github.io/">首页</a> </li>
      <li><a href="http://binbean.github.io//categories/">分类</a> </li>
      <li><a href="http://binbean.github.io//tags/">标签</a> </li>
      
    </ul>

    <br/>
    <br/>
    <p>Copyright (c) 2018, BinBin Wen</p>
    <p>Powered by Hugo 0.40.3</p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Javascript Good Part读书笔记</h1>
  <span class="post-date">2018-11-02 10:10:44
    
  </span>
  

<h2 id="语法">语法</h2>

<h3 id="空格-whitespace">空格（Whitespace）</h3>

<p>注释方式，<strong>建议尽量使用行注释形式</strong></p>

<ul>
<li><p>行注释形式 //</p></li>

<li><p>块注释形式 /* */</p></li>
</ul>

<p>块注释形式有时候可能不安全，会引起语法错误</p>

<pre><code>  /*
      var rm_a = /a*/.match(s);
  */
</code></pre>

<h3 id="命名-names">命名（Names）</h3>

<p>命名由字母、数字、下划线(_)组成，但不能与保留字相同。保留字如下：</p>

<pre><code>abstract
boolean break byte
case catch char class const continue
debugger default delete do double
else enum export extends
false final finally float for function
goto
if implements import in instanceof int interface
long
native new null
package private protected public
return
short static super switch synchronized
this throw throws transient true try typeof
var volatile void
while with
</code></pre>

<h3 id="数字-numbers">数字（Numbers）</h3>

<p>Javascript只有一个数字类型，内部为一个64位（64-bit）的浮点数。没有单独的整形（integer），因此1和1.0是相同的值。NaN不等于任何值（包括它自己），可以通过isNaN(number)函数判断。</p>

<h3 id="字符串-strings">字符串（Strings）</h3>

<ol>
<li>一个字符串字面上被单引号（&rsquo;）或双引号（&rdquo;）包裹，包含0个或多个字符，<code>\</code>是转义字符。</li>
<li>每个字符占16-bit宽度。</li>
<li>没有单独的字符类型</li>
</ol>

<p>转义字符表</p>

<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>\&ldquo;</td>
<td>双引号（double quote）</td>
</tr>

<tr>
<td>\&lsquo;</td>
<td>单引号（single quote）</td>
</tr>

<tr>
<td>\</td>
<td>反斜杠（backslash）</td>
</tr>

<tr>
<td>\/</td>
<td>斜杠（slash）</td>
</tr>

<tr>
<td>\b</td>
<td>空格（backspace）</td>
</tr>

<tr>
<td>\f</td>
<td>跳页符（formfeed）</td>
</tr>

<tr>
<td>\n</td>
<td>换行（new line）</td>
</tr>

<tr>
<td>\r</td>
<td>回车（carriage return）</td>
</tr>

<tr>
<td>\t</td>
<td>tab</td>
</tr>

<tr>
<td>\u</td>
<td>Unicode字符，4个16进制数</td>
</tr>
</tbody>
</table>

<h3 id="声明-语句-statement">声明/语句（Statement）</h3>

<ul>
<li>变量 var</li>
<li>条件 if, swtich</li>
<li>循环 while, for, do</li>
<li>中断 break, return, throw</li>
</ul>

<ol>
<li><p>一个代码块被打括号（{）包裹，由一组声明/语句组成，但在Javascript中没有块作用域，因此变量应该被声明到函数的上面，而不是代码块里面。</p></li>

<li><p>false值</p></li>
</ol>

<ul>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>&rdquo;&ldquo;/&rdquo;  空字符串</li>
<li>0</li>
<li>NaN</li>
</ul>

<ol>
<li>true值</li>
</ol>

<ul>
<li>其它值</li>
<li>true</li>
<li>&lsquo;false&rsquo;字符串</li>
<li>所有对象</li>
</ul>

<ol>
<li><p>switch的case子句应该有break，防止继续进入下一个子句。</p></li>

<li><p>for循环的两种形式</p>

<ul>
<li><p>for</p></li>

<li><p>for in</p></li>
</ul>

<p>主要用于对象的属性遍历，通常需要通过object.hasOwnProperty(variable)判断该对象是否包含成员变量（<strong>该方法不会在原型连上查找</strong>）。</p></li>

<li><p>如果return语句没有具体说明，则返回undefined。</p></li>
</ol>

<h3 id="表达式-expressions">表达式（Expressions）</h3>

<p>typeof表达式返回的值包括：<code>number</code>, <code>string</code>, <code>boolean</code>, <code>undefined</code>,<code>function</code>,<code>object</code>,</p>

<ol>
<li><p>如果操作数是array或null则返回<code>object</code></p></li>

<li><p>如果对象属性不存在则返回undefined（<strong>会在原型链上查找</strong>）</p></li>
</ol>

<pre><code>   typeof flight.number   // 'number'
   typeof flight.status   // 'string'
   typeof flight.arrival  // 'object'
   typeof flight.manifest // 'undefined'
   
   //原型链查找
   typeof flight.toString // 'function' 
   typeof flight.constructor // 'function'
</code></pre>

<h3 id="字面符号-literals">字面符号（Literals）</h3>

<ul>
<li>number</li>
<li>string</li>
<li>object</li>
<li>array</li>
<li>function</li>
<li>regex</li>
</ul>

<h2 id="对象-objects">对象（Objects）</h2>

<p>包括简单类型：number， string， boolean，null，undefined和对象类型两种。number， string， boolean类似对象类型，有自己的方法（method）但是是不可变的。在JavaScript中，数组（arrays）是对象、函数（function）是对象、正则表达式（regular expressions）是对象、对象（objects）是对象。</p>

<h3 id="对象字面符-object-literals">对象字面符（Object Literals）</h3>

<p>对象是一个name/value对的集合,通过<code>,</code>分隔。name可以是任何字符串（包括空字符串），如果name是一个合法的JavaScript名字并且不是保留字，则可以不用引号包裹。</p>

<p>对象持有一个隐藏的链接指向原型对象，通过字面符号创建的对象链接指向<code>Object.portotype</code>。</p>

<pre><code>var empty_object = {};
var stooge = { 
	&quot;first-name&quot;: &quot;Jerome&quot;, 
	&quot;last-name&quot;: &quot;Howard&quot;
};
var flight = {
	airline: &quot;Oceanic&quot;, 
	number: 815, 
	departure: {
		IATA: &quot;SYD&quot;,
		time: &quot;2004-09-22 14:55&quot;, 
		city: &quot;Sydney&quot;
	}, 
	arrival: {
		IATA: &quot;LAX&quot;,
		time: &quot;2004-09-23 10:42&quot;,
    city: &quot;Los Angeles&quot;
	} 
};
</code></pre>

<h3 id="获取值-retrieval">获取值（Retrieval）</h3>

<ul>
<li>下标方式</li>
</ul>

<pre><code>  stooge[&quot;first-name&quot;] // &quot;Jerome&quot;
</code></pre>

<ul>
<li><code>.</code>方式</li>
</ul>

<pre><code>  flight.departure.IATA // &quot;SYD&quot;
</code></pre>

<p>如果试图访问一个存在的对象成员，则返回undefined。</p>

<pre><code>stooge[&quot;middle-name&quot;]   // undefined
flight.status           // undefined
stooge[&quot;FIRST-NAME&quot;]    // undefined
</code></pre>

<p>试图从undefined获取值则会抛出（throw）一个TypeError异常，可以通过&amp;&amp;操作符来避免。</p>

<pre><code>flight.equipment                           // undefined
flight.equipment.model                     // throw &quot;TypeError&quot;
flight.equipment &amp;&amp; flight.equipment.model // undefined
</code></pre>

<h3 id="更新值-update">更新值（Update）</h3>

<p>如果属性/成员名已经存在则会更新，否则会为对象添加属性并赋值。</p>

<ul>
<li>下标方式</li>
</ul>

<pre><code>  stooge['first-name'] = 'Jerome';
</code></pre>

<ul>
<li><code>.</code>方式</li>
</ul>

<pre><code>  stooge.nickname = 'Curly'; 
  flight.equipment = {
  	model: 'Boeing 777' 
  };
  flight.status = 'overdue';
</code></pre>

<h3 id="引用-reference">引用（Reference）</h3>

<p>对象通过引用传递，不会进行拷贝。</p>

<pre><code>var x = stooge; 
x.nickname = 'Curly';
var nick = stooge.nickname;   // Curly
var a =
nick = stooge.nickname;
// a, b, c 引用不同的空对象
var a = {}, b = {}, c = {};
// a, b, c 引用同一个空对象
var a = b = c = {};
</code></pre>

<h3 id="原型-prototype">原型（Prototype）</h3>

<p>所有通过字面符号创建的对象都链接到了<code>Object.prototype</code>。在获取对象的值时，如果对象没有该属性，则会在原型链上逐级查找，直到<code>Object.prototype</code>，如果没有找到则返回undefined值。</p>

<pre><code>if (typeof Object.create !== 'function') { 
	Object.create = function (o) {
		var F = function () {}; 
		F.prototype = o;
		return new F();
	};
}

var another_stooge = Object.create(stooge);

another_stooge['first-name'] = 'Harry'; 
another_stooge['middle-name'] = 'Moses'; 
another_stooge.nickname = 'Moe';
</code></pre>

<p>原型链关系是一种动态关系，当对原型对象添加属性或修改属性值时，基于该原型的对象将立即可见。</p>

<pre><code>stooge.profession = 'actor'; 
another_stooge.profession // 'actor'
</code></pre>

<h3 id="列举-遍历-enumeration">列举/遍历（Enumeration）</h3>

<p>for in循环会遍历对象上的所有属性（包括原型对象上的）。</p>

<h3 id="删除-delete">删除（Delete）</h3>

<p>可以通过<code>delete</code>删除对象的属性，但是不能删除原型链对象的属性。</p>

<pre><code>delete another_stooge.nickname;
</code></pre>

<h3 id="减少全局变量-global-abatement">减少全局变量（Global Abatement）</h3>

<pre><code>var MYAPP = {};
MYAPP.stooge = { 
	&quot;first-name&quot;: &quot;Joe&quot;, 
	&quot;last-name&quot;: &quot;Howard&quot;
};
</code></pre>

<h2 id="函数-functions">函数（Functions）</h2>

<h3 id="函数对象-function-objects">函数对象（Function Objects）</h3>

<p>在JavaScript中函数就是对象（Functions in Javascript are objects）,通过字面符产生的对象指向<code>Object.prototype</code>，函数对象指向<code>Function.prototype</code>,<code>Function.prototype</code>指向<code>Object.prototype</code>。每个函数被创建后带有一个<code>prototype</code>属性，<code>prototype</code>属性的值是一个包含<code>constructor</code>属性的对象，而<code>constructor</code>属性的值是该函数（function）。</p>

<h3 id="函数字面符号-function-literal">函数字面符号（Function Literal）</h3>

<p>通过字面符号创建函数对象。</p>

<pre><code>var add = function (a, b) { 
	return a + b;
};
</code></pre>

<h3 id="调用-invocation">调用（Invocation）</h3>

<p>每个函数接受两个额外的参数：<code>this</code>, <code>arguments</code>。可通过4种模式调用函数，每种。</p>

<ol>
<li>方法调用（method invocation）</li>
</ol>

<p>当一个函数被赋值/存储为一个对象属性，文件叫它为一个方法。当一个方法调用时this被绑定到这个对象上。</p>

<pre><code>   // Create myObject. It has a value and an increment 
   // method. The increment method takes an optional
   // parameter. If the argument is not a number, then 1 
   // is used as the default.
   var myObject = { 
   	value: 0,
   	increment: function (inc) {
   		this.value += typeof inc === 'number' ? inc : 1;
   	} 
   };
   myObject.increment(); 
   document.writeln(myObject.value);   // 1
   myObject.increment(2); 
   document.writeln(myObject.value);    // 3
</code></pre>

<ol>
<li>函数调用（function invocation）</li>
</ol>

<p>一个函数不是一个对象属性是，被当作函数调用，此时this被绑定到global对象。当内部函数被调用时，this仍然被绑定到了外部函数。</p>

<pre><code>   myObject.double = function () {
   	var that = this; // Workaround.
   	var helper = function () {
   		that.value = add(that.value, that.value);
   	};
   	helper(); // Invoke helper as a function. 
   };
   // Invoke double as a method.
   myObject.double( ); 
   document.writeln(myObject.value);
</code></pre>

<ol>
<li>构造函数调用（constructor invocation）</li>
</ol>

<p>当一个函数通过<code>new</code> 前缀调用，一个新的对象将被创建，this与新创建的对象绑定。</p>

<p>当一个函数被定义使用<code>new</code>调用时，被叫做构造器（constructor），习惯上首字母大写，用于与普通函数区分。</p>

<pre><code>   // Create a constructor function called Quo. 
   // It makes an object with a status property.
   var Quo = function (string) { 
   	this.status = string;
   };
   // Give all instances of Quo a public method
   // called get_status.
   Quo.prototype.get_status = function () { 
   	return this.status;
   };
   // Make an instance of Quo.
   var myQuo = new Quo(&quot;confused&quot;);
   document.writeln(myQuo.get_status()); // confused
</code></pre>

<ol>
<li>apply调用（apply invocation）</li>
</ol>

<p>apply方法包括两个参数，第一个参数用于绑定this，第二个参数是一个数组。</p>

<pre><code>   // Make an array of 2 numbers and add them.
   var array = [3, 4];
   var sum = add.apply(null, array); // sum is 7
   // Make an object with a status member.
   var statusObject = { 
   	status: 'A-OK'
   };
   // statusObject does not inherit from Quo.prototype, // but we can invoke the get_status method on
   // statusObject even though statusObject does not have // a get_status method.
   var status = Quo.prototype.get_status.apply(statusObject); // status is 'A-OK'
</code></pre>

<h3 id="参数-arguments">参数（Arguments）</h3>

<p>每个函数被调用时都有一个隐式的arguments参数，包含了调用的参数，可以通过类似数组的方式访问，但是arguments 不是一个真正的数组（只有<code>length</code>属性，没有数组的任何方法）。</p>

<h3 id="返回值-return">返回值（Return）</h3>

<p>一个函数总会返回一个值，如果没有指定则返回<code>undefined</code>。如果一个函数通过<code>new</code>的方式调用返回<code>this</code>（new的对象）。</p>

<p>异常（Exceptions）</p>

<p><code>throw</code>语句会打断一个函数的执行，一个<code>exception</code>对象包括一个<code>name</code>属性（唯一标示一个异常类型）和一个<code>message</code>属性（异常描述）。</p>

<pre><code>var add = function (a, b) {
	if (typeof a !== 'number' || typeof b !== 'number') {
		throw {
			name: 'TypeError',
			message: 'add needs numbers'
		}; 
	}
	return a + b; 
}
</code></pre>

<p><code>try</code>语句只有一个<code>catch</code>块（捕获所有的异常），如果有多种类型的异常需哟处理，可根据异常名称确定异常的类型。</p>

<pre><code>var try_it = function () { 
	try {
		add(&quot;seven&quot;); 
	} catch (e) {
		document.writeln(e.name + ': ' + e.message); 
	}
}
try_it( );
</code></pre>

<h3 id="扩展类型功能">扩展类型功能</h3>

<p>在JavaScript中可以对基本类型进行功能扩展。对<code>Object.prototype</code>添加方法对所有对象都可用，包括：函数（functions）、数组（arrays）、字符串（strings）、数字（numbers）、正则表达式（regular expressions）、布尔（booleans）。</p>

<p>通过<code>Function.prototype</code>添加方式对所有的函数都有效。</p>

<pre><code>Function.prototype.method = function (name, func) { 
	this.prototype[name] = func;
	return this;
};
</code></pre>

<pre><code>// Add a method conditionally.
Function.prototype.method = function (name, func) { 
	if (!this.prototype[name]) {
		this.prototype[name] = func;
    return this;
  }
};
</code></pre>

<p>添加整数方法到Number</p>

<pre><code>Number.method('integer', function () {
  return Math[this &lt; 0 ? 'ceil' : 'floor'](this);
});
</code></pre>

<pre><code>document.writeln((-10 / 3).integer()); // -3
</code></pre>

<p>添加删除空格的方法到string</p>

<pre><code>String.method('trim', function () {
	return this.replace(/^\s+|\s+$/g, '');
});
</code></pre>

<pre><code>document.writeln('&quot;' + &quot; neat &quot;.trim() + '&quot;');
</code></pre>

<h3 id="递归-recursion">递归（Recursion）</h3>

<p>尾部递归优化</p>

<pre><code>// Make a factorial function with tail
// recursion. It is tail recursive because 
// it returns the result of calling itself.
// JavaScript does not currently optimize this form.
var factorial = function factorial(i, a) { 
	a = a || 1;
  if (i &lt; 2) {
  	return a;
	}
	return factorial(i - 1, a * i);
};
document.writeln(factorial(4)); // 24
</code></pre>

<h3 id="作用域-scope">作用域（Scope）</h3>

<p>JavaScript只有函数作用域，没有块作用域。最好在函数体的顶部声明变量。</p>

<pre><code>var = function () { 
	a = 3, b = 5;
	var bar = function () { 
		var b = 7, c = 11;
		// At this point, a is 3, b is 7, and c is 11 
		a += b + c;
    // At this point, a is 21, b is 7, and c is 11
  };
	// At this point, a is 3, b is 5, and c is not defined 
	bar();
  // At this point, a is 21, b is 5
};
</code></pre>

<h3 id="闭包-closure">闭包（Closure）</h3>

<p>内部函数可以访问定义它的外部函数的参数和变量（<strong>this和arguments除外</strong>）。</p>

<p>通过闭包实现封装，保护不想让外部程序访问的属性。</p>

<pre><code>// 不是赋值一个函数给对象，而是赋值一个函数调用的返回值。
var myObject = (function () { 
	var value = 0;
  return {
  	increment: function (inc) {
			value += typeof inc === 'number' ? inc : 1; 
		},
		getValue: function () { 
			return value;
		} 
	};
}());
</code></pre>

<pre><code>var quo = function (status) { 
	return {
			get_status: function () { return status;
			} 
	};
};

// Make an instance of quo.
var myQuo = quo(&quot;amazed&quot;);
document.writeln(myQuo.get_status( ));
</code></pre>

<p>例子</p>

<pre><code>// Define a function that sets a DOM node's color 
// to yellow and then fades it to white.
var fade = function (node) { 
	var level = 1;
	var step = function () {
		var hex = level.toString(16); 
		node.style.backgroundColor = '#FFFF' + hex + hex; 
		if (level &lt; 15) {
			level += 1;
      setTimeout(step, 100);
    }
	};
  setTimeout(step, 100);
};
fade(document.body);
</code></pre>

<p>正例（<strong>避免在循环中创建函数</strong>）</p>

<pre><code> var add_the_handlers = function (nodes) { 
 	var helper = function (i) {
   	return function (e) {
     	alert(i);
 		}; 
 	};
 	var i;
 	for (i = 0; i &lt; nodes.length; i += 1) {
 		nodes[i].onclick = helper(i); 
 	}
};
</code></pre>

<p>反例（<strong>弹出框提示总是最后一个值</strong>）</p>

<pre><code>var add_the_handlers = function (nodes) { 
	var i;
	for (i = 0; i &lt; nodes.length; i += 1) { 
		nodes[i].onclick = function (e) {
			alert(i); 
		};
	} 
};
</code></pre>

<h3 id="回调-callbacks">回调（Callbacks）</h3>

<p>在异步请求中传递一个函数作为参数，当响应返回时该函数被调用。</p>

<pre><code>request = prepare_the_request();
response = send_request_synchronously(request); 
display(response);
</code></pre>

<p>使用回调方式</p>

<pre><code>request = prepare_the_request(); send_request_asynchronously(request, function (response) {
	display(response);
});
</code></pre>

<h3 id="模块化-module">模块化（Module）</h3>

<p>我们可以使用函数和闭包实现模块化。一个模块是一个函数或对象的接口表现，隐藏了具体的实现和状态。</p>

<pre><code>String.method('deentityify', function () {
	// The entity table. It maps entity names to characters.
	var entity = { 
		quot: '&quot;',
		lt: '&lt;',
		gt: '&gt;' 
	};
	// Return the deentityify method. 
	return function () {
		// This is the deentityify method. It calls the string 
		// replace method, looking for substrings that start 
		// with '&amp;' and end with ';'. If the characters in
		// between are in the entity table, then replace the 
		// entity with the character from the table. 
		return this.replace(/&amp;([^&amp;;]+);/g, function (a, b) {
			var r = entity[b];
			return typeof r === 'string' ? r : a; 
		}); 
	};
}());

</code></pre>

<pre><code>document.writeln( '&amp;lt;&amp;quot;&amp;gt;'.deentityify()); // &lt;&quot;&gt;
</code></pre>

<h3 id="及联调用-cascade">及联调用（Cascade）</h3>

<p>如果一个函数返回<code>this</code>则可以使用及联调用。</p>

<h3 id="柯里化-curry">柯里化（Curry）</h3>

<p>柯里化允许我们通过组合一个函数和一个参数产生一个新的函数。JavaScript没有柯里化方法，我们可以通过给<code>Function.prototpe</code>添加一个方法实现。</p>

<pre><code>Function.method('curry', function () { 
	var slice = Array.prototype.slice, 
		args = slice.apply(arguments),
		that = this; 
	return function () {
		return that.apply(null, args.concat(slice.apply(arguments))); 
	};
});
</code></pre>

<pre><code>var add1 = add.curry(1); 
document.writeln(add1(6)); // 7
</code></pre>

<h3 id="内存化-memoization">内存化（Memoization）</h3>

<p>函数使用对象保存前一个操作的结果，从而避免不必要的重复计算。</p>

<pre><code>var fibonacci = function (n) {
	return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
};

for (var i = 0; i &lt;= 10; i += 1) { 
	document.writeln('// ' + i + ': ' + fibonacci(i));
}
</code></pre>

<p>内存化后</p>

<pre><code>var fibonacci = (function () { 
	var memo = [0, 1];
	var fib = function (n) {
		var result = memo[n];
		if (typeof result !== 'number') {
			result = fib(n - 1) + fib(n - 2);
			memo[n] = result; 
		}
    return result;
  };
	return fib; 
}());
</code></pre>

<p>提出函数</p>

<pre><code>var memoizer = function (memo, formula) { 
	var recur = function (n) {
		var result = memo[n];
		if (typeof result !== 'number') {
			result = formula(recur, n);
			memo[n] = result; 
		}
  	return result;
  };
  return recur;
};
</code></pre>

<pre><code>var fibonacci = memoizer([0, 1], function (recur, n) { 
	return recur(n - 1) + recur(n - 2);
});

var factorial = memoizer([1, 1], function (recur, n) { 
	return n * recur(n - 1);
});
</code></pre>

<h2 id="继承-inheritance">继承（Inheritance）</h2>

<h3 id="伪类-pseudoclassical">伪类（Pseudoclassical）</h3>

<p>当一个函数对象被创建时，这个函数的构造器会产生一个函数对象运行类似下面的代码：</p>

<pre><code>this.prototype = {constructor: this};
</code></pre>

<p>例子，定义一个构造器，并在prototype上添加方法</p>

<pre><code>var Mammal = function (name) { 
	this.name = name;
};
Mammal.prototype.get_name = function () { 
	return this.name;
};
Mammal.prototype.says = function () { 
	return this.saying || '';
};
</code></pre>

<p>创建实例</p>

<pre><code>var myMammal = new Mammal('Herb the Mammal');
var name = myMammal.get_name(); // 'Herb the Mammal'
</code></pre>

<p>创建另一个伪类继承Mammal，通过定义该伪类的<code>constructor</code>函数并且替换它的<code>prototype</code>属性为Mammal的实例。</p>

<pre><code>var Cat = function (name) { 
	this.name = name; 
	this.saying = 'meow';
};
// Replace Cat.prototype with a new instance of Mammal
Cat.prototype = new Mammal();
// Augment the new prototype with purr and get_name methods.
Cat.prototype.purr = function (n) { 
	var i, s = '';
	for (i = 0; i &lt; n; i += 1) { 
		if (s) {
			s += '-'; 
		}
		s += 'r'; 
	}
	return s; 
};
Cat.prototype.get_name = function () {
	return this.says() + ' ' + this.name + ' ' + this.says();
};
</code></pre>

<pre><code>var myCat = new Cat('Henrietta');
var says = myCat.says(); // 'meow'
var purr = myCat.purr(5); // 'r-r-r-r-r' 
var name = myCat.get_name(); // 'meow Henrietta meow'
</code></pre>

<p>使用前面定义的<code>method</code>方法定义一个<code>inherits</code>方法：</p>

<pre><code>Function.method('inherits', function (Parent) { 
	this.prototype = new Parent();
	return this;
});
</code></pre>

<p>因为<code>inherits</code>和<code>method</code>方法都返回<code>this</code>，我们可以通过及联调用的方式实现Cat</p>

<pre><code>var Cat = function (name) { 
this.name = name; 
this.saying = 'meow';
}.inherits(Mammal)
.method('purr', function (n) {
var i, s = '';
for (i = 0; i &lt; n; i += 1) {
	if (s) {
		s += '-';
	}
	s += 'r'; 
}
return s; 
})
.method('get_name', function () {
return this.says() + ' ' + this.name + ' ' + this.says();
});
</code></pre>

<p>伪类继承存在的问题</p>

<ul>
<li>没有私有属性/方法（JavaScript所有属性都是公有的）。</li>
<li>不能访问父类的方法。</li>
<li>如果调用的时候忘记了<code>new</code>（没有以构造函数的方式调用），则<code>this</code>不能被绑定到新创建的对象实例（this将会被绑定到全局对象）。</li>
</ul>

<h3 id="对象说明符-object-specifiers">对象说明符（Object Specifiers）</h3>

<p>当一个构造器有非常多的参数时，参数的顺序会变的非常难记，这时候可以通过对象描述符代替。</p>

<p>例如：</p>

<pre><code>var myObject = maker(f, l, m, c, s);
</code></pre>

<p>可以写为：</p>

<pre><code>var myObject = maker({
	first: f,
	last: l,
  middle: m,
  state: s,
  city: c
});
</code></pre>

<h3 id="原型-prototypal">原型（Prototypal）</h3>

<p>基于原型的继承方式比经典的继承在概念上更为简单，并且更容易理解。</p>

<p>示例</p>

<pre><code>var myMammal = {
	name : 'Herb the Mammal', 
	get_name : function () {
		return this.name; 
	},
	says : function () {
		return this.saying || '';
	} 
};
</code></pre>

<p>创建对象实例</p>

<pre><code>var myCat = Object.create(myMammal); 
myCat.name = 'Henrietta'; 
myCat.saying = 'meow';
myCat.purr = function (n) {
	var i, s = '';
	for (i = 0; i &lt; n; i += 1) {
		if (s) {
			s += '-';
		}
		s += 'r'; 
	}
	return s; 
};
myCat.get_name = function () {
	return this.says() + ' ' + this.name + ' ' + this.says();
};
</code></pre>

<h3 id="函数化-functional">函数化（Functional）</h3>

<p>通过模块化的方式实现封装，可通过如下4步实现</p>

<ol>
<li>创建一个对象，创建对象的方式：

<ul>
<li>字面符</li>
<li>通过<code>new</code>调用构造器</li>
<li>从一个已经存在的对象使用<code>Object.create</code>方法新建一个实例</li>
<li>调用一个函数返回一个对象</li>
</ul></li>
<li>定义私有的实例变量和方法（<strong>可选</strong>）</li>
<li>为创建的对象增加方法（这鞋方法有权限去访问底2步中定义的变量/方法）</li>
<li>返回新建的对象。</li>
</ol>

<p>伪代码如下：</p>

<pre><code>var constructor = function (spec, my) {
	var that, other private instance variables; 
	my = my || {};
	Add shared variables and functions to my 
	that = a new object;
	Add privileged methods to that
	return that;
};
</code></pre>

<p>示例</p>

<pre><code>var mammal = function (spec) {
	var that = {};
	that.get_name = function () { 
		return spec.name;
	};
	that.says = function () { 
		return spec.saying || '';
	};
  return that;
};
var myMammal = mammal({name: 'Herb'});
</code></pre>

<pre><code>var cat = function (spec) {
	spec.saying = spec.saying || 'meow'; 
	var that = mammal(spec);
	that.purr = function (n)
		var i, s = '';
		for (i = 0; i &lt; n; i
			if (s) {
				s += '-';
			}
			s += 'r'; 
		}
		return s; 
	};
	that.get_name = function(){
		return that.says() + ' ' + spec.name + ' ' + that.says();
	};
	return that;
};
var myCat = cat({name: 'Henrietta'});
</code></pre>

<p>访问父类方法</p>

<pre><code>Object.method('superior', function (name) { 
	var that = this,
	method = that[name]; 
	return function () {
		return method.apply(that, arguments); 
	};
});
</code></pre>

<p>示例</p>

<pre><code>var coolcat = function (spec) { 
	var that = cat(spec),
			super_get_name = that.superior('get_name'); 
	that.get_name = function (n) {
		return 'like ' + super_get_name() + ' baby'; };
    return that;
  };  
var myCoolCat = coolcat({name: 'Bix'}); 
var name = myCoolCat.get_name();
// 'like meow Bix meow baby'
</code></pre>

<h3 id="部件-parts">部件（Parts）</h3>

<p>一个给任何对象添加简单事件处理的函数。</p>

<h2 id="数组-arrays">数组（Arrays）</h2>

<p>JavaScript数组实际上是对象。</p>

<h3 id="数组字面符">数组字面符</h3>

<pre><code>var empty = [];
var numbers = [
	'zero', 'one', 'two', 'three', 'four',
	'five', 'six', 'seven', 'eight', 'nine'
];
empty[1]     // undefined
numbers[1]   // 'one'
empty.length   // 0 
numbers.length // 10
</code></pre>

<h3 id="length">Length</h3>

<p>JavaScript数组的<code>length</code>不是容量的上限，<code>length</code>属性的值是这个数组的最大属性名加1。</p>

<pre><code>var myArray = []; 
myArray.length // 0
myArray[1000000] = true;
myArray.length // 1000001
</code></pre>

<p><code>length</code>可以被显式的设置，设置比<code>length</code>更大的值不会给数组分配更多的空间，设置比<code>length</code>小的值则会删除下表大于等于新<code>length</code>的属性。</p>

<pre><code>numbers.length = 3;
// numbers is ['zero', 'one', 'two']

numbers[numbers.length] = 'shi';
// numbers is ['zero', 'one', 'two', 'shi']

numbers.push('go');
// numbers is ['zero', 'one', 'two', 'shi', 'go']
</code></pre>

<h3 id="delete">Delete</h3>

<p><code>delete</code>操作会从数组中删除元素。（只会删除值，但原有的名称/属性会被保留）。</p>

<pre><code>delete numbers[2];
// numbers is ['zero', 'one', undefined, 'shi', 'go']
</code></pre>

<p>如果要真正删除一个元素可以使用<code>splice</code>方法</p>

<pre><code>numbers.splice(2, 1);
// numbers is ['zero', 'one', 'shi', 'go']
</code></pre>

<h3 id="enumeration">Enumeration</h3>

<p><code>for in</code> 语句可以用于迭代数组的所有属性，但是不能保证自然数字顺序。更好的选择是使用普通<code>for</code>循环，。</p>

<pre><code>var i;
for (i = 0; i &lt; myArray.length; i += 1) {
	document.writeln(myArray[i]); 
}
</code></pre>

<p>关于使用数组和对象的困惑</p>

<blockquote>
<p>当属性名称是小的一系列的数字时使用数组，否则使用对象。</p>
</blockquote>

<p>数组判断</p>

<pre><code>var is_array = function (value) {
	return Object.prototype.toString.apply(value) === '[object Array]';
};
</code></pre>

<h3 id="方法-methods">方法（methods）</h3>

<p>可以通过<code>Array.prototype</code>扩充数组方法。</p>

<pre><code>Array.method('reduce', function (f, value) { 
	var i;
	for (i = 0; i &lt; this.length; i += 1) { 
		value = f(this[i], value);
	}
  return value;
});
</code></pre>

<pre><code>// Create an array of numbers.
var data = [4, 8, 15, 16, 23, 42];
// Define two simple functions. One will add two 
// numbers. The other will multiply two numbers.
var add = function (a, b) { 
	return a + b;
};
var mult = function (a, b) { 
	return a * b;
};
// Invoke the data's reduce method, passing in the
// add function.
var sum = data.reduce(add, 0); // sum is 108
// Invoke the reduce method again, this time passing 
// in the multiply function.
var product = data.reduce(mult, 1); // product is 7418880
</code></pre>

<p>可以直接给数组添加属性，但是<code>length</code>长度不会增加</p>

<pre><code>// Give the data array a total function.
data.total = function () { 
	return this.reduce(add, 0);
};
total = data.total(); // total is 108
</code></pre>

<h3 id="范围-dimensions">范围（Dimensions）</h3>

<p>数组默认不会初始化，如果访问不存在的元素会返回<code>undefined</code>。</p>

<p>一维数组初始化方法</p>

<pre><code>Array.dim = function (dimension, initial) { 
	var a = [], i;
	for (i = 0; i &lt; dimension; i += 1) { 
		a[i] = initial;
	}
	return a; 
};
// Make an array containing 10 zeros. 
var myArray = Array.dim(10, 0);
</code></pre>

<p>二维数组初始化</p>

<pre><code>Array.matrix = function (m, n, initial) { 
	var a, i, j, mat = [];
	for (i = 0; i &lt; m; i += 1) {
		a = [];
		for (j = 0; j &lt; n; j += 1) {
			a[j] = initial; 
		}
		mat[i] = a;
	}
  return mat;
};
// Make a 4 * 4 matrix filled with zeros. 
var myMatrix = Array.matrix(4, 4, 0);
</code></pre>

<h2 id="正则表达式-regular-expressions">正则表达式（Regular Expressions）</h2>

<h3 id="例子">例子</h3>

<pre><code>var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.-A-Za-z]+) (?::(\d+))?(?:\/( (?#)))?(?:\?( (#)))?(?:#(.*))?$/;
</code></pre>

<p>解析</p>

<pre><code>1 ^表示正则字符串开始
2 (?:([A-Za-z]+):)?  匹配schema（可选），将结果放入第1组（不包括:）
3 (\/{0,3})  匹配0或1或2或3个/，将结果放入第2组
4 ([0-9.-A-Za-z]+) 匹配主机名，包括数字,-大小写字母。将结果放入第3组
5 (?::(\d+))?  匹配端口号。将结果放入第4组（不包括:）
6 (?:\/( ( ( (?#)))))? 匹配请求路径（可选），排除?#。将结果放入第5组（不包括/）
7 (?:\?( ( ( (#)))))? 匹配查询（可选），排除#。将结果放入第6组（不包括?）
8 (?:#(.*))?  匹配hash（可选）。将结果放入第7组（不包括#）
</code></pre>

<pre><code>var url = &quot;http://www.ora.com:80/goodparts?q#fragment&quot;;
var result = parse_url.exec(url);
var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
var blanks = ' '; 
var i;
for (i = 0; i &lt; names.length; i += 1) { 
	document.writeln(names[i] + ':' +
	blanks.substring(names[i].length), result[i]);
}

// produces
url: http://www.ora.com:80/goodparts?q#fragment 
scheme: http
slash: //
host: www.ora.com
port: 80
path: goodparts
query: q
hash: fragment
</code></pre>

<h3 id="标识符">标识符</h3>

<pre><code>1 ^开始标识符
2 (?:...)标识不捕获的分组
3 ?标识分组可选，可匹配0或1次，same as {0,1} 
4 (...)标识捕获分组
5 [...]标识字符类，A-Za-z包括26个大小写字母
6 +标识匹配1或多次， same as {1,} 
7 \是转义符
8 {0,3}标识匹配0或1或2或3次。如果量词包含?后缀，则会倾向于懒惰匹配
9 \d数字字符
10  (...]标识需要排除的字符，例如[^?#):排除？和#
11 *标识匹配0或多次，same as {0,}.
12 .标识匹配任何字符
13 $结束标识符
</code></pre>

<h3 id="flag标识">Flag标识</h3>

<table>
<thead>
<tr>
<th>Flag</th>
<th>意思</th>
</tr>
</thead>

<tbody>
<tr>
<td>g</td>
<td>全局</td>
</tr>

<tr>
<td>i</td>
<td>忽略大小写</td>
</tr>

<tr>
<td>m</td>
<td>多行</td>
</tr>
</tbody>
</table>

<h3 id="转义">转义</h3>

<table>
<thead>
<tr>
<th>转义符</th>
<th>意思</th>
</tr>
</thead>

<tbody>
<tr>
<td>\f</td>
<td>跳页</td>
</tr>

<tr>
<td>\n</td>
<td>换行</td>
</tr>

<tr>
<td>\r</td>
<td>回车</td>
</tr>

<tr>
<td>\t</td>
<td>制表符</td>
</tr>

<tr>
<td>\u</td>
<td>Unicode字符</td>
</tr>

<tr>
<td>\b</td>
<td>空格</td>
</tr>

<tr>
<td>\d</td>
<td>[0-9]</td>
</tr>

<tr>
<td>\D</td>
<td>[^0-9]</td>
</tr>

<tr>
<td>\s</td>
<td>[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</td>
</tr>

<tr>
<td>\S</td>
<td>[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</td>
</tr>

<tr>
<td>\w</td>
<td>[0-9A-Za-z]</td>
</tr>

<tr>
<td>\W</td>
<td>[^0-9A-Za-z]</td>
</tr>
</tbody>
</table>

<h3 id="需要转义的字符">需要转义的字符</h3>

<pre><code>-/[] ^ 
</code></pre>

<h3 id="32个特殊的ascii字符">32个特殊的ASCII字符</h3>

<pre><code>`! &quot;#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~`

//可以这样写
(?:!|&quot;|#|$|%|&amp;|'|(|)|*|+|,|-|.|\/|:|;|&lt;|=|&gt;|@|[|\|]|\^|_||\{|\||\}|~)

//简单写法
[!-\/:-@\[-{-~]

</code></pre>

<h2 id="方法-methods-1">方法（Methods）</h2>

<h3 id="数组-array">数组（array）</h3>

<ul>
<li>array.concat(item&hellip;)</li>
</ul>

<p>通过浅拷贝产生一个新的数组，并添加item到这个数组。</p>

<pre><code>  var a = ['a', 'b', 'c'];
  var b = ['x', 'y', 'z'];
  var c = a.concat(b, true);
  // c is ['a', 'b', 'c', 'x', 'y', 'z', true]
</code></pre>

<ul>
<li>array.join(separator)</li>
</ul>

<p>生成一个字符串由<code>separator</code>分割的字符串，默认分隔符是<code>,</code>。</p>

<pre><code>var a = ['a', 'b', 'c'];
a.push('d');
var c = a.join(''); // c is 'abcd';
</code></pre>

<ul>
<li>array.pop()</li>
</ul>

<p>删除并返回数组的最后一个元素，如果是空数组则返回 <code>undefined</code>。</p>

<pre><code> var a = ['a', 'b', 'c'];
 var c = a.pop(); // a is ['a', 'b'] &amp; c is 'c'
</code></pre>

<p>可实现为：</p>

<pre><code> Array.method('pop', function () {
  	return this.splice(this.length - 1, 1)[0];
  });
</code></pre>

<ul>
<li>array.push(item&hellip;)</li>
</ul>

<p>追加item到数组末尾，返回数组长度。</p>

<pre><code> var a = ['a', 'b', 'c'];
 var b = ['x', 'y', 'z'];
 var c = a.push(b, true);
 // a is ['a', 'b', 'c', ['x', 'y', 'z'], true] 
 // c is 5;
</code></pre>

<p>可实现为：</p>

<pre><code>Array.method('push', function () { 
  	this.splice.apply(
  		this,		[this.length,0].concat(Array.prototype.slice.apply(arguments))); 
  		return this.length;
});
</code></pre>

<ul>
<li>array.reverse()</li>
</ul>

<p>反转数组元素，返回一个数组。</p>

<pre><code>var a = ['a', 'b', 'c'];
var b = a.reverse();
// both a and b are ['c', 'b', 'a']
</code></pre>

<ul>
<li>array.shift()</li>
</ul>

<p>删除数组的第一个元素并返回该元素，如果是空数组则返回<code>undefined</code>。通常比<code>pop</code>方法慢很多（需要进行元素移动）。</p>

<pre><code>var a = ['a', 'b', 'c'];
var c = a.shift(); 
// a is ['b', 'c'] &amp; c is 'a'
</code></pre>

<p>可实现为：</p>

<pre><code>Array.method('shift', function () { 
  return this.splice(0, 1)[0];
});
  

</code></pre>

<ul>
<li>array.slice(start, end)</li>
</ul>

<p>数组一部的的浅拷贝</p>

<pre><code>var a = ['a', 'b', 'c'];  
var b = a.slice(0, 1);     // b is ['a'] 
var c = a.slice(1);        // c is ['b', 'c']
var d = a.slice(1, 2);     // d is ['b']
</code></pre>

<ul>
<li>array*.splice(*start, deleteCount, item&hellip;)</li>
</ul>

<p>从一个数组删除元素，并返回被删除的元素<strong>数组</strong>。如果有item参数，则从start位置替换/插入这些元素。</p>

<ul>
<li>start参数表示开始的位置</li>
<li>deleteCount表示从start开始删除元素的个数</li>
</ul>

<pre><code>var a = ['a', 'b', 'c'];
var r = a.splice(1, 1, 'ache', 'bug'); 
// a is ['a', 'ache', 'bug', 'c']
// r is ['b']
</code></pre>

<ul>
<li>array.sort(comparefn)</li>
</ul>

<p>数组排序，默认假设数组是字符串。数字排序会出错。</p>

<pre><code> var n = [4, 8, 15, 16, 23, 42]; 
 n.sort( );
 // n is [15, 16, 23, 4, 42, 8]
</code></pre>

<p>数字排序</p>

<pre><code> n.sort(function (a, b) { 
  	return a - b;
 });
 // n is [4, 8, 15, 16, 23, 42];
</code></pre>

<p>数字，字符串混合排序</p>

<pre><code> var m = ['aa', 'bb', 'a', 4, 8, 15, 16, 23, 42]; m.sort(function (a, b) {
  	if (a === b) { 
  		return 0;
  	}
  	if (typeof a === typeof b){
  		return a &lt; b ? -1 : 1; 
  	}
    return typeof a &lt; typeof b ? -1 : 1;
 });
 // m is [4, 8, 15, 16, 23, 42,'a', 'aa', 'bb']
</code></pre>

<p>对象单属性排序</p>

<pre><code>var by = function (name) { 
  	return function (o, p) {
  		var a, b;
  		if (typeof o === 'object' 
  			&amp;&amp; typeof p === 'object' &amp;&amp; o &amp;&amp; p) {
  			a = o[name];
  			b = p[name]; 
  			if (a === b) {
  				return 0; 
  			}
  			if (typeof a === typeof b) { 
  				return a &lt; b ? -1 : 1;
  			}
  			return typeof a &lt; typeof b ? -1 : 1;
  		} else {
  			throw {
  				name: 'Error',
  				message: 'Expected an
  		}; 
  };
  s.sort(by('first')).sort(by('last'));
</code></pre>

<p>对象多属性排序</p>

<pre><code> var by = function (name, minor) { 
  	return function (o, p) {
  		var a, b;
  		if (o &amp;&amp; p &amp;&amp; typeof o === 'object' 
  			&amp;&amp; typeof p === 'object') {
  			a = o[name];
  			b = p[name]; 
  			if (a === b) {
  				return typeof minor === 'function' ? minor(o, p) : 0; 
  			}
  			if (typeof a === typeof b) { 
  				return a &lt; b ? -1 : 1;
  			}
  			return typeof a &lt; typeof b ? -1 : 1; 
  		} else {
  			throw {
  				name: 'Error',
	 				message: 'Expected an object when sorting by ' + name				};
  		} 
  	};
  };
  s.sort(by('last', by('first')));
</code></pre>

<ul>
<li>array.unshift(item&hellip;)</li>
</ul>

<p>在数组开头添加item元素，返回数组的新长度。</p>

<pre><code>var a = ['a', 'b', 'c'];
var r = a.unshift('?', '@');
// a is ['?', '@', 'a', 'b', 'c'] // r is 5
</code></pre>

<p>可实现为：</p>

<pre><code>Array.method('unshift', function () { 
  this.splice.apply(
  	this,
  	[0, 0].concat(Array.prototype.slice.apply(arguments))); 		return this.length;
});
</code></pre>

<p>### 函数（Function）</p>

<ul>
<li>function.apply(thisArg, argArray)</li>
</ul>

<p>调用一个函数，传递this的对象绑定和一个可选的参数数组。</p>

<h3 id="数字-number">数字（Number）</h3>

<ul>
<li><em>number</em>.toExponential(<em>fractionDigits</em>)</li>
</ul>

<p>转换数字到字符串，<em>fractionDigits</em> 0~20</p>

<pre><code>document.writeln(Math.PI.toExponential(0)); document.writeln(Math.PI.toExponential(2)); document.writeln(Math.PI.toExponential(7)); document.writeln(Math.PI.toExponential(16)); document.writeln(Math.PI.toExponential( ));

  // Produces
  3e+0
  3.14e+0
  3.1415927e+0 
  3.1415926535897930e+0 
  3.141592653589793e+0
</code></pre>

<ul>
<li><em>number</em>.toFixed(<em>fractionDigits</em>)</li>
</ul>

<p>转换数字到字符串，<em>fractionDigits</em> 0~20，默认0</p>

<pre><code> document.writeln(Math.PI.toFixed(0)); document.writeln(Math.PI.toFixed(2)); document.writeln(Math.PI.toFixed(7)); document.writeln(Math.PI.toFixed(16)); document.writeln(Math.PI.toFixed());

  // Produces
  3
  3.14
  3.1415927 
  3.1415926535897930 
  3
</code></pre>

<ul>
<li>number*.toPrecision(*precision)</li>
</ul>

<p>转换数字到字符串，precision 1~21</p>

<pre><code>document.writeln(Math.PI.toPrecision(2)); document.writeln(Math.PI.toPrecision(7)); document.writeln(Math.PI.toPrecision(16)); document.writeln(Math.PI.toPrecision());

  // Produces
  3.1
  3.141593 
  3.141592653589793 
  3.141592653589793
</code></pre>

<ul>
<li><em>number</em>.toString(<em>radix</em>)</li>
</ul>

<p>转换数字到字符串。</p>

<pre><code>document.writeln(Math.PI.toString(2)); document.writeln(Math.PI.toString(8)); document.writeln(Math.PI.toString(16)); document.writeln(Math.PI.toString( ));

  // Produces
  11.001001000011111101101010100010001000010110100011 3.1103755242102643
  3.243f6a8885a3
  3.141592653589793
</code></pre>

<h3 id="对象-object">对象（Object）</h3>

<ul>
<li>object.hasOwnProperty(name)</li>
</ul>

<p>如果对象包含属性名则返回true（<strong>不会在原型链上查找</strong>）</p>

<pre><code> var a = {member: true};
 var b = Object.create(a);
 var t = a.hasOwnProperty('member');  // t is true
 var u = b.hasOwnProperty('member');  // u is false
 var v = b.member;                    // v is true
</code></pre>

<p>### 正则表达式（RegExp）</p>

<ul>
<li>regexp.exec(string)</li>
</ul>

<p>如字符串成功匹配的正则表达式，则返回一个数组，数组的第0个元素为匹配的子字符串，从1开始依次为捕获的分组。如果匹配失败则返回<code>null</code></p>

<ul>
<li>regexp.test(string)</li>
</ul>

<p>测试字符串是否匹配正则表达式，如果匹配则返回<code>true</code>,否则返回<code>false</code>。<strong>不要使用<code>g</code>标记</strong></p>

<pre><code>var b = /&amp;.+;/.test('frank  beans'); // b is true
</code></pre>

<pre><code> RegExp.method('test', function (string) { 
  return this.exec(string) !== null;
  });
</code></pre>

<p>### 字符串（String）
* string.charAt(pos)</p>

<pre><code>var name = 'Curly';
var initial = name.charAt(0); // initial is 'C'
</code></pre>

<pre><code>  String.method('charAt', function (pos) { 
    return this.slice(pos, pos + 1);
  });
</code></pre>

<ul>
<li>string.charCodeAt(pos)</li>
</ul>

<pre><code>var name = 'Curly';
var initial = name.charCodeAt(0); // initial is 67
</code></pre>

<ul>
<li>string.concat(string&hellip;)</li>
</ul>

<pre><code>var s = 'C'.concat('a', 't'); // s is 'Cat'
</code></pre>

<ul>
<li>string.indexOf(searchString, position)</li>
</ul>

<pre><code> var text = 'Mississippi'; 
 var p = text.indexOf('ss');  // p is 2
 p = text.indexOf('ss', 3);   // p is 5
 p = text.indexOf('ss', 6);   // p is -1
</code></pre>

<ul>
<li>string.lastIndexOf(searchString, position)</li>
</ul>

<pre><code> var text = 'Mississippi';
 var p = text.lastIndexOf('ss');  // p is 5
 p = text.lastIndexOf('ss', 3);   // p is 2
 p = text.lastIndexOf('ss', 6);   // p is 5
</code></pre>

<ul>
<li>string.localeCompare(that)</li>
</ul>

<pre><code>  var m = ['AAA', 'A', 'aa', 'a', 'Aa', 'aaa']; 
  m.sort(function (a, b) {
  	return a.localeCompare(b); 
  });
  // m (in some locale) is
  // ['a', 'A', 'aa', 'Aa', 'aaa', 'AAA']
</code></pre>

<ul>
<li>string.match(regexp)</li>
</ul>

<pre><code> var text = '&lt;html&gt;&lt;body bgcolor=linen&gt;&lt;p&gt;' +
  	'This is &lt;b&gt;bold&lt;\/b&gt;!&lt;\/p&gt;&lt;\/body&gt;&lt;\/html&gt;';
  var tags = / (&lt;&gt;)+|&lt;(\/?)([A-Za-z]+)( (&lt;&gt;)*)&gt;/g; 
  var a, i;
  a = text.match(tags);
  for (i = 0; i &lt; a.length; i += 1) {
  	document.writeln(('// [' + i + '] ' + a[i]).entityify()); 
  }
  // The result is
  // [0] &lt;html&gt;
  // [1] &lt;body bgcolor=linen&gt; // [2] &lt;p&gt;
  // [3] This is
  // [4] 
  // [5] bold
  // [6] 
  // [7] !
  // [8] &lt;/p&gt;
  // [9] &lt;/body&gt;
  // [10] &lt;/html&gt;
</code></pre>

<ul>
<li>string.replace(searchValue, replaceValue)</li>
</ul>

<pre><code>var result = &quot;mother_in_law&quot;.replace('_', '-');

var oldareacode = /((\d{3}))/g;
var p = '(555)666-1212'.replace(oldareacode, '$1-'); 
  // p is '555-666-1212'
</code></pre>

<p>符号替换</p>

<table>
<thead>
<tr>
<th>Dollar sequence</th>
<th>Replacement</th>
</tr>
</thead>

<tbody>
<tr>
<td>$$</td>
<td>$</td>
</tr>

<tr>
<td>$&amp;</td>
<td>匹配的文本</td>
</tr>

<tr>
<td>$number</td>
<td>获取的分组文本</td>
</tr>

<tr>
<td>$`</td>
<td>匹配之前的文本</td>
</tr>

<tr>
<td>$&rsquo;</td>
<td>匹配之后的文本</td>
</tr>
</tbody>
</table>

<pre><code>String.method('entityify', function () {
  var character = { 
  		'&lt;' : '', 
  		'&gt;' : '',
  		'&amp;' : '',
  		'&quot;' : '' 
  	};
  // Return the string.entityify method, which
  // returns the result of calling the replace method. 
  // Its replaceValue function returns the result of 
  // looking a character up in an object. This use of 
  // an object usually outperforms switch statements.
  	return function () {
  		return this.replace(/[&lt;&gt;&amp;&quot;]/g, function (c) {
      	return character[c];
      });
  	}; 
  }());
  alert(&quot;&lt;&amp;&gt;&quot;.entityify()); // &lt;&amp;&gt;
</code></pre>

<ul>
<li>string.search(regexp)</li>
</ul>

<pre><code>var text = 'and in it he says &quot;Any damn fool could'; 
var pos = text.search(/[&quot;']/); // pos is 18
</code></pre>

<ul>
<li>string.slice(start, end)</li>
</ul>

<pre><code>var text = 'and in it he says &quot;Any damn fool could'; 
var a = text.slice(18);
// a is '&quot;Any damn fool could'
var b = text.slice(0, 3);
// b is 'and'
var c = text.slice(-5);
// c is 'could'
var d = text.slice(19, 32); // d is 'Any damn fool'
</code></pre>

<ul>
<li>string.split(separator, limit)</li>
</ul>

<pre><code>var digits = '0123456789';
var a = digits.split('', 5);
  // a is ['0', '1', '2', '3', '4']

  var ip = '192.168.1.0';
  var b = ip.split('.');
  // b is ['192', '168', '1', '0']

  var c = '|a|b|c|'.split('|'); 
  // c is ['', 'a', 'b', 'c', '']

  ar text = 'last, first ,middle'; var d = text.split(/\s,\s/);
  // d is [
  // 'last',
  // 'first',
  // 'middle' // ]

  var e = text.split(/\s(,)\s/); // e is [
  // 'last',
  // ',',
  // 'first',
  // ',',
  // 'middle' // ]

  var f = '|a|b|c|'.split(/|/);
  // f is ['a', 'b', 'c'] on some systems, and // f is ['', 'a', 'b', 'c', ''] on others
</code></pre>

<ul>
<li><p>string.substring(start, end)</p></li>

<li><p>string.toLocaleLowerCase( )</p></li>

<li><p>string.toLocaleUpperCase( )</p></li>

<li><p>string.toLowerCase( )</p></li>

<li><p>string.toUpperCase( )</p></li>

<li><p>String.fromCharCode(char&hellip;)</p></li>
</ul>

<pre><code>var a = String.fromCharCode(67, 97, 116); 
// a is 'Cat'
</code></pre>

</div>
<hr />
<blockquote>
<p>本文为学习过程记录，因能力有限，如有错误请赐教……如需转载，请注明出处！<a href="https://binbean.github.io/">https://binbean.github.io</a></p>
</blockquote>




<div id="git-comments"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
  var gitment = new Gitment({
    id: '20181102101044',  
    owner: 'binbean',
    repo: 'Gitment',
    oauth: {
      client_id: '5abe7f2c0a045b632a03',
      client_secret: '5e344f27030ca6bff90af981e47272a1848e3bea',
    }
  })
  gitment.render('git-comments')
</script>
    </div>

    
  </body>
</html>
